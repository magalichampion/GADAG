##' @title Analyse GADAG results.
##' @description Function to analyse GADAG results.
##' @param Results Outputs from GADAG_Run() function.
##' @param G Adjacency graph corresponding to the true DAG (pxp matrix).
##' @param X Design matrix with samples (n) in rows and variables (p) in columns.
##' @param threshold Thresholding value for the edges.
##' @param PlotControl A list containing parameters to control the prodcued graph outputs:
##' \itemize{
##' \item \code{plot.graph} If TRUE, generates the figures with the actual and estimated graphs,
##' \item \code{plot.evol} If TRUE, generates the figures showing the evolution of the genetic algorithm (fitness value, Shannon entropy and best node ordering),
##' \item \code{plot.png} If TRUE, saves the figures in .png.
##' }
##' @return A vector containing the scores of precision, recall, number of false positives (FP), false negatives (FN), true positives (TP), true negatives (TN) and mean squared error.
##' @author \packageAuthor{GADAG}
##' ##' @details GADAG aims at recovering the structure of an unknow DAG G, which edges represent the interactions that exist between p nodes, using n noisy observations
##' of these nodes (design matrix X).
##' GADAG is more precisely based on a l1-penalized (to make the estimated graph sparse enough) maximum log-likelihood estimation procedure, with the constraint that the estimated graph is a DAG.
##' This DAG learning problem is particularly critical in the high-dimensional setting, the exploration of
##' the whole of set of DAGs being a NP-hard problem.
##' GADAG proposes an original formulation for the estimated DAG, splitting the
##' initial problem into two sub-problems: node ordering and graph topology search.
##' The node order, modelled as a permutation of [1,p] or the associated pxp matrix P, will represent the importance of the p nodes of the graph,
##' from the node with the smallest number of children to the node with the largest number of children.
##' The topological structure of the graph, which is given as a lower triangular matrix T,
##' could then set the graph edges weights (including 0, equivalent to no edges).
##' GADAG works as follows:  it efficiently looks for the best permution in an outer loop with a genetic algorithm,
##' while a nested loop is used to find the optimal T associated to each given P. The latter internal optimization
##' problem is solved by a steepest gradient descent approach.
##'
##' @examples
##'  #############################################################
##'  # Loading toy data
##'  #############################################################
##'  data(toy_data)
##'  # toy_data is a list of two matrices corresponding to a "star"
##'  # DAG (node 1 activates all other nodes):
##'  # - toy_data$X is a 100x10 design matrix
##'  # - toy_data$G is the 10x10 adjacency matrix (ground trough)
##'
##'  ########################################################
##'  # Evaluating GADAG Results
##'  ########################################################
##'  # simple run, where you only get the precision, recall, number
##'  # of false positives, true positives, false negatives, true negatives
##'  # and mean squared error of the estimated graph
##'
##'  # run GADAG with the predefined parameters
##'  GADAG_results <- GADAG_Run(X=toy_data$X, lambda=0.1)
##'
##'  # analyze the results
##'  GADAG_analysis <- GADAG_Analyse(GADAG_results, G=toy_data$G, X=toy_data$X)
##'
##'  # more complex run, where you want to have some details about the procedure
##'  \dontrun{
##'  # run GADAG with return.level set to 1 beforehand
##'  GADAG_results <- GADAG_Run(X=toy_data$X, lambda=0.1,return.level=1)
##'
##'  # print the evolution of the algorithm
##'  plot.evol <- TRUE
##'  GADAG_analysis <- GADAG_Analyse(GADAG_results, G=toy_data$G, X=toy_data$X,
##'           PlotControl = list(plot.evol=TRUE))
##'
##'  # in addition, print the estimated and the true graph
##'  plot.graph <- TRUE
##'  GADAG_analysis <- GADAG_Analyse(GADAG_results, G=toy_data$G, X=toy_data$X,
##'           PlotControl = list(plot.evol=plot.evol, plot.graph= plot.graph))
##'
##'  # now save the results in .png, but only for the graphs
##'  plot.png <- TRUE
##'  GADAG_analysis <- GADAG_Analyse(GADAG_results, G=toy_data$G, X=toy_data$X,
##'           PlotControl = list(plot.graph= plot.graph, plot.png = plot.png))
##'  }
##'
##'

GADAG_Analyse <- function(Results,G,X,threshold=0.1,PlotControl=list(plot.graph=FALSE,plot.evol=FALSE,plot.png=FALSE)){

  #############################################################
  # INPUTS:
  # Results: a list generated by GADAG_Run, containing:
  #      f.best: best fitness value
  #      P.best: best individual (node order)
  #      T.best: corresponding best triangular matrix (edges values)
  #      G.best: best graph
  # G: actual G matrix
  # X: matrix of observations (n*p)
  # threshold: thresholding value for the edges
  # plot.graph: if TRUE, generates the figures with the actual and estimated graphs
  # plot.evol: if TRUE, generates the figures showing the evolution of the algorithm (return.level of the main algo has to be = 1)
  # plot.png: if TRUE, saves the figures in .png
  # OUTPUTS
  # A vector containing the scores of precision, recall, FP, FN, TP, TN, MSE
  #############################################################

  n <- dim(X)[1]
  p <- dim(X)[2]

  if (is.null(PlotControl$plot.graph)){
    plot.graph <- FALSE
  } else {
    plot.graph <- PlotControl$plot.graph
  }
  if (is.null(PlotControl$plot.evol)){
    plot.evol <- FALSE
  } else {
    plot.evol <- PlotControl$plot.evol
  }
  if (is.null(PlotControl$plot.png)){
    plot.png <- FALSE
  } else {
    plot.png <- PlotControl$plot.png
  }

  if (plot.png==TRUE && plot.graph==FALSE && plot.evol==FALSE){
    cat("No graphs are produced and saved. Please turn on plot.graph or plot.evol.")
  }

  P <- chrom(Results$P.best)
  T <- matrix(data=Results$T.best,p,p)
  T[T<threshold] <- 0
  G.best <- P %*% T %*% t(P)

  # Compute values (FP, FN, TP, TN, MSE)
  Gbest.bin <- G.bin <- G*0
  Gbest.bin[(abs(G.best)>0)] <- 1
  G.bin[(abs(G)>0)] <-1

  FP <- sum(Gbest.bin-G.bin==1)
  FN <- sum(Gbest.bin-G.bin==-1)
  TP <- sum(Gbest.bin!=0) - FP
  TN <- p*(p-1) - TP - FN - FP
  MSE <- (1/(n*p)) * sum((X-X%*%G.best)^2)
  precision <- TP / ( TP + FP )
  recall    <- TP / ( TP + FN )

  if (plot.graph) {
    net1 <- graph.adjacency(G.bin)
    net2 <- graph.adjacency(Gbest.bin)
    lay1 <- layout.kamada.kawai(net1)
    if (plot.png==TRUE){
      png("TrueDAG.png")
      plot(net1,main="True DAG", layout=lay1)
      dev.off()
      png("EstimatedDAG.png")
      plot(net2,main="Estimated DAG", layout=lay1)
      dev.off()
    } else {
      par(mfrow=c(1,2))
      plot(net1,main="True DAG", layout=lay1)
      plot(net2,main="Estimated DAG", layout=lay1)
    }
  }

  if (plot.evol){
    if (length(Results)<12){
      cat("You don't have enough results to plot anything. Please turn return.level to 1 in the main algorithm. \n")
    } else {
      Node_highlight <- which(rbind(rowSums(abs(G)>0),colSums(abs(G)>0))==max(rbind(rowSums(abs(G)>0),colSums(abs(G)>0))),arr.ind=TRUE)[,1]
      col <- rep("black", p)
      col[Node_highlight] <- rainbow(length(Node_highlight))
      lwd <- rep(1, p)
      lwd[Node_highlight] <- 2

      # Fpop, min, mean and quantiles
      ylim=c(min(Results$fmin.evol),max(Results$fp90.evol))
      if (plot.png==TRUE){
        png("FitnessEvolution.png")
        plot(Results$f.best.evol, type="l", main="Cost function", xlab="Generation #", ylab="-logLikelihood", lwd=2, col="red",
          ylim=ylim)
        polygon(x=c(1:length(Results$fp10.evol),rev(1:length(Results$fp10.evol))), y=c(Results$fp10.evol, rev(Results$fp90.evol)), border=NA,col="lightgrey")
        lines(Results$fmean.evol)
        lines(Results$fp10.evol)
        lines(Results$fp90.evol)
        legend("topright", legend=c("Current best", "Population"), col=c("red","black"), lwd=c(2,1))
        dev.off()


        # Shannon
        png("ShannonEvolution.png")
        plot(Results$Shannon.evol[,1], type="l", main="Shannon entropy", xlab="Generation #", ylab="Entropy", ylim=c(0, max(Results$Shannon.evol)),
          col=col[1], lwd=lwd[1])
        for (i in 2:p) lines(Results$Shannon.evol[,i], col=col[i], lwd=lwd[i])
        legend("topright",legend=paste0("Node ",Node_highlight),lwd=lwd[Node_highlight], col=col[Node_highlight])
        dev.off()

        # Nodes paths - bestever
        png("BestNodesEvolution.png")
        A <- which(Results$P.best.evol==1, arr.ind=TRUE)
        a <- sort(A[,1], index.return=TRUE)$ix
        plot(A[a,1], A[a,2], ylim=c(0,p), type="l", main="Best permutation", xlab="Generation #", ylab="Node path", col=col[1], lwd=lwd[1])
        for (i in 2:p){
          A <- which(Results$P.best.evol==i, arr.ind=TRUE)
          a <- sort(A[,1], index.return=TRUE)$ix
          lines(A[a,1], A[a,2], col=col[i], lwd=lwd[i])
        }
        legend("topright", legend=paste0("Node ",Node_highlight), lwd=lwd[Node_highlight], col=col[Node_highlight])
        dev.off()
      } else {
        par(mfrow=c(1,1))
        plot(Results$f.best.evol, type="l", main="Cost function", xlab="Generation #", ylab="-logLikelihood", lwd=2, col="red",
             ylim=ylim)
        polygon(x=c(1:length(Results$fp10.evol),rev(1:length(Results$fp10.evol))), y=c(Results$fp10.evol, rev(Results$fp90.evol)), border=NA,col="lightgrey")
        lines(Results$fmean.evol)
        lines(Results$fp10.evol)
        lines(Results$fp90.evol)
        legend("topright", legend=c("Current best", "Population"), col=c("red","black"), lwd=c(2,1))

        # Shannon
        plot(Results$Shannon.evol[,1], type="l", main="Shannon entropy", xlab="Generation #", ylab="Entropy", ylim=c(0, max(Results$Shannon.evol)),
             col=col[1], lwd=lwd[1])
        for (i in 2:p) lines(Results$Shannon.evol[,i], col=col[i], lwd=lwd[i])
        legend("topright",legend=paste0("Node ",Node_highlight),lwd=lwd[Node_highlight], col=col[Node_highlight])

        # Nodes paths - bestever
        A <- which(Results$P.best.evol==1, arr.ind=TRUE)
        a <- sort(A[,1], index.return=TRUE)$ix
        plot(A[a,1], A[a,2], ylim=c(0,p), type="l", main="Best permutation", xlab="Generation #", ylab="Node path", col=col[1], lwd=lwd[1])
        for (i in 2:p){
          A <- which(Results$P.best.evol==i, arr.ind=TRUE)
          a <- sort(A[,1], index.return=TRUE)$ix
          lines(A[a,1], A[a,2], col=col[i], lwd=lwd[i])
        }
        legend("topright", legend=paste0("Node ",Node_highlight), lwd=lwd[Node_highlight], col=col[Node_highlight])
      }
    }
  }
  options(scipen=50)
  val <- c(precision, recall, FP,FN,TP,TN,MSE)
  names(val)<-c("precision", "recall", "FP", "FN", "TP", "TN","MSE")
  return(val)
}
